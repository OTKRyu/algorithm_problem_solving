# algorithm

## practice

### 논리와 증명

- 문제 1-2 : (~pvq)v(p^~q)의 진리표

| p    | q    | (~pvq) | (p^~q) | (~pvq)v(p^~q) |
| ---- | ---- | ------ | ------ | ------------- |
| F    | T    | T      | F      | T             |
| F    | F    | T      | F      | T             |
| T    | T    | T      | F      | T             |
| T    | F    | F      | T      | T             |

- 문제 2-2 : (p^q)^(p^~q)의 진리표

| p    | q    | (p^q) | (p^~q) | (p^q)^(p^~q) |
| ---- | ---- | ----- | ------ | ------------ |
| F    | T    | F     | F      | F            |
| F    | F    | F     | F      | F            |
| T    | T    | T     | F      | F            |
| T    | F    | F     | T      | F            |

-  문제 3-2 : ~pv~q, ~(pvq)

| p    | q    | ~pv~q | ~(pvq) |
| ---- | ---- | ----- | ------ |
| F    | T    | T     | F      |
| F    | F    | T     | T      |
| T    | T    | F     | F      |
| T    | F    | T     | F      |

-  문제 4-2 : (pv~q)^(~pv~q)

(pv~q)^(~pv~q) = (p^~p)v~q= Fv~q=~q

-  문제 5-2 : all x in Z, x^2 >= x

T

-  문제 5-4 : some x in Z, x^2 < x

F

-  문제 7 : n이 홀수이면 n^2+n은 짝수임을 증명

어떤 홀수 n이 주어졌다고 가정하자, 이러면 n = 2k +1 이렇게 표현할 수 있다.

n^2 +n = (2k+1)^2 + 2k+1=4k^2 +6k + 2 = 2(2k^2+3k+1) 이렇게 표현될 수 있다.

n^2+n은 2로 나누었을 때 2k^2+3k+1이라는 정수를 몫으로 나누어 떨어지므로 짝수이다.

- 문제 9 : 자연수n에 대해 n^2 + 5가 홀수이면 n은 짝수임을 증명

대우 n이 홀수이면 n^2+5는 짝수이다.

n = 2k + 1그러면 4k^2 + 4k +6 = 2(2k^2+2k+3) 고로 짝수이다.

- 문제 11 : 자연수 n에 대해 n^2 + 5n + 3은 언제나 홀수임을 증명하라.

어떤 자연수 n이 주어졌다고 가정하자.

그렇다면 자연수 n은 홀수이거나 짝수이다.

짝수일 경우 n = 2k라고 한다면 n^2+5n+3 = 4k^2 + 10k+3 = 2(2k^2+5k+1) +1이므로 홀수이다.

홀수일 경우 n = 2k+1라고 한다면 n^2+5n+3 = 4k^2+4k+1 +10k+5 + 3 = 4k^2+14k+ 9 = 2(2k^2+7k+4)+1이므로 홀수이다.

### 수와 표현

- 문제 2 : 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지 인가?

2^20

- 문제 3-2 : n이 충분히 큰 값일 때, 2^(n/2), sqrt(3^n) 누가 더 큰가

2^(n/2) < 3^(n/2) = (3^n)^(1/2) = sqrt(3^n)

- 문제 3-4 : n이 충분히 큰 값일 때, log(2)(2^2n), n*sqrt(n) 누가 더 큰가

log(2)(2^2n) = 2nlog(2)(2) = 2n < n*sqrt(n) if n > 4

### 집합과 조합론

- 문제 3 : n개의 원소를 가진 집합의 가능한 부분집합의 종류는 2^n개임을 증명하라

문제 2번에서 이항정리를 증명했으므로 이를 활용하도록 하자.

결국 n개의 원소를 가진 집합의 가능한 부분집합의 원소의 갯수는 0~n개일 것이다. 

이 때 k개의 원소를 가진 부분집합을 구성하는 원소를 뽑는 방법은 nCk이다.

고로 모든 부분집합의 가능성은 nC1 + nC2 + ... +nCn-1 + nCn이 된다.

이 값은 이항정리의 x,y값에 각각 1,1을 넣었을 때 나오는 값이므로 (1+1)^n= 2^n이 된다.

- 문제 10 : 0~9까지의 수를 최대 한번 사용할 수 있다고 할 때 4~6자리 비밀번호로 가능한 가짓수는 몇 개인가?

10P4 + 10P5 + 10P6 

- 문제 13 : 52개의 카드를 이용해서 만들 수 있는 5개 카드 조합 중 같은 무늬의 카드가 정확히 3개인 경우는 몇가지인가?

4 * 13C3 \*3\*13\*2\*13

### 기초수식

- 문제 2: T(n) = T(n-1) +n

O(n^2)

- 문제 4 : T(n) = T(n/2) + 1

O(log(2)(n))

- 문제 6 : T(n) = 2T(n/2) + n

O(n\*log(2)(n))

### 재귀

- 문제 2 : 크기 n인 배열을 merge sort할시의 알고리즘과 정확성 증명 및 시간 복잡도 계산을 수행

알고리즘

```python
def merge_sort(list m):
    if len(m) == 1: return m
    middle = length(m) // 2
    for x in range(middle):
        left.append(m[x])
    for x in range(middle, length(m)):
        right.append(m[x])
    left = merge_sort(left)
   	right = merge_sort(right)
    return merge(left, reight)

def merge(left, right):
    result = []
    while 1: 
    	if len(left) > 0 and length(right) > 0:
        	if left[0] <= right[0]:
            	result.append(left.pop(0))
        	else:
            	result.append(right.pop(0))
        elif len(left) > 0:
            result.append(left.pop(0))
        elif len(right) > 0:
            result.append(left.pop(0))
        else:
            break
    return result
```

정확성 증명

수학적 귀납법을 쓰자.

n=1일 때는 배열의 원소가 하나이므로 정렬되어 있다고 볼 수 있다.

n=k일 때까지 모든 배열이 정렬되어 있다고 가정하자.

n=k+1일 때 자연수 x,y, x+y=k+1인 배열이 주어졌다고 가정하자.

그렇다면 x,y는 일단 가정에 의해 정렬되어 있다.

위 알고리즘대로 x,y를 결합해 k+1짜리 배열을 정렬했다고 가정하자.

WLOG, 0<=idx_a<idx_b<k+1라고 하자.

그렇다면 케이스는 크게 2가지로 a,b가 같은 배열(x or y)에 소속되어 있던가, a,b가 서로 다른 배열에 소속된 경우다.

첫 번째 케이스로 보면, a,b가 모두 같은 배열에 속해있었고 그 배열이 정렬되어 있었기 때문에 a는 b보다 작다.(같은 배열에서 병합되었다면 왼쪽에서 오른쪽으로 작은 순서대로 병합되었기때문에)

두 번째 케이스로 보면, WLOG a in x, b in y라고 가정해보자.

일단 idx_a<idx_b 이기 때문에 병합순서상 b쪽이 늦게 병합이 되었다.

c가 idx_b에 병합되기 전 마지막으로 들어간 x의 원소라고 가정해보자.

그런 원소 c가 없다고 가정한다면, idx_b에 다다르기까지의 모든 원소가 y에서 들어갔다는 얘기인데 그렇다면 이건 a,b가 같은 y에서 나왔다는 얘기가 되므로 가정에 모순이다. 즉 그런 원소 c는 항상 존재한다.

그렇다면 c<=b이고 c보다 같거나 먼저 들어간 원소가 a이기 때문에 a<=c<=b이므로 정렬은 성립한다.

시간 복잡도

쪼개는 데 들어가는 시간 : 최대 O(n)

병합하는 데 걸리는 시간 : 최대 O(n * log(2)(n))

2*n/2 +2^2\*(n/(2^2)) + ... + n <= n * log(2)(n) 

따라서 이 둘 모두를 시행하는 시간 : O(n+n * log(2)(n)) = O(n * lon(2)(n))

### 동적 프로그래밍

- 문제 1 : memoization 피보나치 수열

```python
n = int(input())
Fs = [0] * (n+1)
Fs[1] = 1
Fs[2] = 1
def F(n):
    if F[n] != 0:
        return F[n]
    else:
        F[n] = F(n-1) + F(n-2)
        return F[n]
```

정확성 증명

피보나치 수열을 만드는 방식 그대로를 쓰되 값이 변하지 않으므로 저장해가면서 쓰는 것에 불과하다

시간 복잡도 계산

F[n]까지의 값을 채우는 순간 끝이나므로 n-2회의 연산이 일어나고 나머지 연산은 리스트의 값을 참조하는 데 쓰이게 된다. 참조할 때의 속도는 연산의 속도보다 월등히 빠르므로 무시한다고 하면 O(n), 혹은 참조하는 시간도 고려한다고 해도 2n-3정도이므로 여전히 O(n)정도면 구할 수 있다.