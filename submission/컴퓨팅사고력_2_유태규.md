# algorithm

## homework

### 기초수식

- 문제 8 : T(n) = T(n-1) +  1/n

T(n) = 1/n + 1/(n-1) + 1/(n-2) + ... + 1/1

for some k that 2^k <= n < 2^(k+1)

T(n) <= 1/2^k + 1/2^k + 1/2^(k-1) + ... + 1/2 + 1/1 = 1/2 + 1/2 +1/2 + ... 1/2+ 1 이고  

1/2이 나오는 갯수가 log(2)(k)이므로 log(2)(k) * (1/2 ) + 1이 된다.

O(log(2)(n))

### 재귀

- 문제 6 : dynamic programming 피보나치 수열

알고리즘

```python
n = int(input())
Fs = [0] * (n+1)
Fs[1] = 1
Fs[2] = 1
k = 3
while k < n+1:
    Fs[k] = Fs[k-1] + Fs[k-2]
    k += 1
print(Fs[n])
```

정확성 증명

k번째 요소를 피보나치 수열을 만드는 규칙 그대로 가져다가 썼기 때문에 정확히 작동한다.

시간 복잡도 계산

while문이 n-2번 돌고 참조는 그 때마다 3번씩 일어난다. 이 모든 걸 고려해도 O(n)이다.

### 동적 프로그래밍

- 문제 2 : 트리를 프린트하는 알고리즘을 만들어라

알고리즘 코드

```python
def printer(n):
    node = tree[n]
    print(f'[{node[1]}]', end='')
    if node[2]:
        print('--', end='')
        m = len(node[2])
        if len(node[2]) == 1:
            print('---', end='')
            printer(node[2][0])
        else:
            for i in range(m):
                if i == m - 1:
                    print(' ' * (7 + node[3]*10), end='')
                    print('L--', end='')
                    printer(node[2][i])
                elif i == 0:
                    print('+--', end='')
                    printer(node[2][i])
                else:
                    print(' ' * (7 + node[3]*10), end='')
                    print('+--', end='')
                    printer(node[2][i])
    else:
        print()
        return


tree = [0]
tree.append([1, '030', [2, 3, 4], 0])
tree.append([2, '054', [5], 1])
tree.append([3, '002', [], 1])
tree.append([4, '045', [6], 1])
tree.append([5, '001', [], 2])
tree.append([6, '123', [], 2])
printer(1)


```

정확성 증명

일단 이런식으로 출력을 하고 싶다면 도착한 순간 프린트를 해야하기 때문에 전위순회를 해야한다. 이후 재귀를 사용해 자식의 해당하는 원소가 출력될 수 있도록 하고 그 과정이 끝나면 돌아오면서 같은 층의 다음 원소를 출력하게 한다. 이렇게 할 때 앞에서 몇 칸을 띄워야할 지를 정해줘야 해서 층수 또한 인자로 저장해두었다.

시간복잡도

결국 이 모든 프로그램이 이루어지려면 트리에 저장된 모든 원소를 순회해야되기 때문에 트리의 원소의 갯수 n만큼 시간이 든다.

O(n)짜리이다.